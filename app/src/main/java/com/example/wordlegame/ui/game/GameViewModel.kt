package com.example.wordlegame.ui.game

import android.util.Log
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.wordlegame.data.model.Game
import com.example.wordlegame.data.model.GameMode
import com.example.wordlegame.data.model.Guess
import com.example.wordlegame.data.repository.GameRepository
import com.example.wordlegame.utils.DateUtils
import com.example.wordlegame.utils.WordUtils
import kotlinx.coroutines.launch

class GameViewModel(private val repository: GameRepository) : ViewModel() {

    private val _targetWord = MutableLiveData<String>()
    val targetWord: LiveData<String> = _targetWord

    private val _guesses = MutableLiveData<List<Guess>>(emptyList())
    val guesses: LiveData<List<Guess>> = _guesses

    private val _gameMode = MutableLiveData<GameMode>()
    val gameMode: LiveData<GameMode> = _gameMode

    private val _gameStatus = MutableLiveData<GameStatus>(GameStatus.PLAYING)
    val gameStatus: LiveData<GameStatus> = _gameStatus

    private val _currentGuess = MutableLiveData<String>("")
    val currentGuess: LiveData<String> = _currentGuess

    private val _errorMessage = MutableLiveData<String?>()
    val errorMessage: LiveData<String?> = _errorMessage

    private val _wordDefinition = MutableLiveData<String?>()
    val wordDefinition: LiveData<String?> = _wordDefinition

    private val _isValidating = MutableLiveData<Boolean>(false)
    val isValidating: LiveData<Boolean> = _isValidating

    private val maxGuesses = 6
    private var userId: String = ""

    fun setUserId(uid: String) {
        userId = uid
        Log.d("GameViewModel", "User ID set to: $uid")
    }

    fun startGame(mode: GameMode) {
        _gameMode.value = mode
        _targetWord.value = if (mode == GameMode.DAILY) {
            WordUtils.getDailyWord(DateUtils.getTodayDate())
        } else {
            WordUtils.getRandomWord()
        }
        _guesses.value = emptyList()
        _gameStatus.value = GameStatus.PLAYING
        _currentGuess.value = ""
        _wordDefinition.value = null
        Log.d("GameViewModel", "Game started: mode=$mode, word=${_targetWord.value}")
    }

    fun addLetter(letter: Char) {
        val current = _currentGuess.value ?: ""
        if (current.length < 5) {
            _currentGuess.value = current + letter
        }
    }

    fun deleteLetter() {
        val current = _currentGuess.value ?: ""
        if (current.isNotEmpty()) {
            _currentGuess.value = current.dropLast(1)
        }
    }

    fun submitGuess() {
        val guess = _currentGuess.value ?: ""

        if (guess.length != 5) {
            _errorMessage.value = "Word must be 5 letters"
            return
        }

        // Validate with API
        _isValidating.value = true
        viewModelScope.launch {
            val isValid = WordUtils.validateWordWithApi(guess)
            _isValidating.value = false

            if (!isValid) {
                _errorMessage.value = "Not a valid word"
                return@launch
            }

            processGuess(guess)
        }
    }

    private fun processGuess(guess: String) {
        val target = _targetWord.value ?: return
        val result = WordUtils.checkGuess(guess, target)

        val currentGuesses = _guesses.value?.toMutableList() ?: mutableListOf()
        currentGuesses.add(result)
        _guesses.value = currentGuesses
        _currentGuess.value = ""

        // Check win condition
        if (guess.uppercase() == target) {
            _gameStatus.value = GameStatus.WON
            saveGame(true, currentGuesses.size, currentGuesses)
            fetchWordDefinition(target)
        } else if (currentGuesses.size >= maxGuesses) {
            _gameStatus.value = GameStatus.LOST
            saveGame(false, currentGuesses.size, currentGuesses)
            fetchWordDefinition(target)
        }
    }

    private fun fetchWordDefinition(word: String) {
        viewModelScope.launch {
            val definition = WordUtils.getWordDefinition(word)
            _wordDefinition.value = definition
        }
    }

    private fun saveGame(isWin: Boolean, guessesUsed: Int, guessList: List<Guess>) {
        viewModelScope.launch {
            val game = Game(
                id = 0, // Auto-generated by Room
                firestoreId = "", // Will be set by repository
                userId = userId,
                mode = _gameMode.value ?: GameMode.UNLIMITED,
                word = _targetWord.value ?: "",
                guessesUsed = guessesUsed,
                datePlayed = System.currentTimeMillis(),
                isWin = isWin,
                guesses = guessList.map { it.word }
            )

            Log.d("GameViewModel", "Saving game: ${game.word}, isWin=$isWin, userId=$userId")

            // Use repository.saveGame which handles both local and cloud
            val result = repository.saveGame(game)

            if (result.isSuccess) {
                Log.d("GameViewModel", "Game saved successfully")
            } else {
                Log.e("GameViewModel", "Failed to save game: ${result.exceptionOrNull()?.message}")
            }
        }
    }

    fun clearError() {
        _errorMessage.value = null
    }

    suspend fun canPlayDaily(): Boolean {
        return if (userId.isNotEmpty()) {
            !repository.hasPlayedDailyToday(userId)
        } else {
            false
        }
    }
}

enum class GameStatus {
    PLAYING, WON, LOST
}