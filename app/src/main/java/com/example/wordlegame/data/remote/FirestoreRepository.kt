package com.example.wordlegame.data.remote

import android.util.Log
import com.example.wordlegame.data.model.Game
import com.example.wordlegame.data.model.User
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.Query
import kotlinx.coroutines.tasks.await

class FirestoreRepository {
    private val db = FirebaseFirestore.getInstance()
    private val usersCollection = db.collection("users")
    private val gamesCollection = db.collection("games")

    // User operations
    suspend fun createUser(user: User): Result<Unit> {
        return try {
            Log.d("FirestoreRepo", "Creating user: ${user.uid}")
            usersCollection.document(user.uid).set(user).await()
            Result.success(Unit)
        } catch (e: Exception) {
            Log.e("FirestoreRepo", "Failed to create user", e)
            Result.failure(e)
        }
    }

    suspend fun getUser(uid: String): Result<User?> {
        return try {
            val doc = usersCollection.document(uid).get().await()
            val user = doc.toObject(User::class.java)
            Log.d("FirestoreRepo", "Got user: $user")
            Result.success(user)
        } catch (e: Exception) {
            Log.e("FirestoreRepo", "Failed to get user", e)
            Result.failure(e)
        }
    }

    suspend fun updateUserStats(uid: String, totalGames: Int, totalWins: Int): Result<Unit> {
        return try {
            Log.d("FirestoreRepo", "Updating stats for $uid: games=$totalGames, wins=$totalWins")
            usersCollection.document(uid).update(
                mapOf(
                    "totalGames" to totalGames,
                    "totalWins" to totalWins
                )
            ).await()
            Result.success(Unit)
        } catch (e: Exception) {
            Log.e("FirestoreRepo", "Failed to update stats", e)
            Result.failure(e)
        }
    }

    // Game operations
    suspend fun saveGame(game: Game): Result<String> {
        return try {
            Log.d("FirestoreRepo", "Saving game: ${game.word} for user ${game.userId}")

            // Convert game to map for Firestore
            val gameMap = hashMapOf(
                "userId" to game.userId,
                "mode" to game.mode.name,
                "word" to game.word,
                "guessesUsed" to game.guessesUsed,
                "datePlayed" to game.datePlayed,
                "isWin" to game.isWin,
                "guesses" to game.guesses
            )

            val docRef = gamesCollection.add(gameMap).await()
            Log.d("FirestoreRepo", "Game saved with ID: ${docRef.id}")
            Result.success(docRef.id)
        } catch (e: Exception) {
            Log.e("FirestoreRepo", "Failed to save game", e)
            Result.failure(e)
        }
    }

    suspend fun getUserGames(userId: String): Result<List<Game>> {
        return try {
            Log.d("FirestoreRepo", "Getting games for user: $userId")

            val snapshot = gamesCollection
                .whereEqualTo("userId", userId)
                .orderBy("datePlayed", Query.Direction.DESCENDING)
                .get()
                .await()

            val games = snapshot.documents.mapNotNull { doc ->
                try {
                    val data = doc.data
                    if (data != null) {
                        Game(
                            id = 0, // Will be auto-generated by Room
                            firestoreId = doc.id,
                            userId = data["userId"] as? String ?: "",
                            mode = com.example.wordlegame.data.model.GameMode.valueOf(
                                data["mode"] as? String ?: "UNLIMITED"
                            ),
                            word = data["word"] as? String ?: "",
                            guessesUsed = (data["guessesUsed"] as? Long)?.toInt() ?: 0,
                            datePlayed = data["datePlayed"] as? Long ?: 0L,
                            isWin = data["isWin"] as? Boolean ?: false,
                            guesses = (data["guesses"] as? List<*>)?.mapNotNull { it as? String } ?: emptyList()
                        )
                    } else null
                } catch (e: Exception) {
                    Log.e("FirestoreRepo", "Error parsing game document ${doc.id}", e)
                    null
                }
            }

            Log.d("FirestoreRepo", "Retrieved ${games.size} games")
            Result.success(games)
        } catch (e: Exception) {
            Log.e("FirestoreRepo", "Failed to get games", e)
            Result.failure(e)
        }
    }

    suspend fun checkDailyGamePlayed(userId: String, startOfDay: Long, endOfDay: Long): Result<Boolean> {
        return try {
            val snapshot = gamesCollection
                .whereEqualTo("userId", userId)
                .whereEqualTo("mode", "DAILY")
                .whereGreaterThanOrEqualTo("datePlayed", startOfDay)
                .whereLessThan("datePlayed", endOfDay)
                .limit(1)
                .get()
                .await()

            Result.success(!snapshot.isEmpty)
        } catch (e: Exception) {
            Log.e("FirestoreRepo", "Failed to check daily game", e)
            Result.failure(e)
        }
    }
}